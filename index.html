<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Binance Futures RSI EMA Cross Scanner (15m)</title>
  <style>
    body { font-family: monospace; background: #0b0c10; color: #eee; padding: 10px; }
    table { border-collapse: collapse; width: 100%; margin-top: 10px; }
    th, td { border: 1px solid #333; padding: 4px 8px; text-align: left; }
    th { background: #1f2833; }
    .bullish { color: #00ff88; }
    .bearish { color: #ff5555; }
    .loading { color: #ccc; }
  </style>
</head>
<body>
  <h2>ðŸš€ RSI EMA70 / EMA200 Cross Scanner â€” 15m Binance Futures USDT</h2>
  <p id="status" class="loading">Fetching symbols...</p>
  <table>
    <thead>
      <tr><th>Symbol</th><th>Cross Type</th><th>Candle Time</th></tr>
    </thead>
    <tbody id="results"></tbody>
  </table>

<script>
function calculateEMA(data, period) {
  const k = 2 / (period + 1);
  const ema = [];
  let prevEma = null;
  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) { ema.push(NaN); continue; }
    if (i === period - 1) {
      const sma = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
      prevEma = sma;
    }
    if (prevEma !== null) {
      const currEma = data[i] * k + prevEma * (1 - k);
      ema.push(currEma);
      prevEma = currEma;
    }
  }
  return ema;
}

function calculateRSI(closes, period = 14) {
  if (!Array.isArray(closes) || closes.length <= period) return [];
  const rsi = [];
  let gains = 0, losses = 0;
  for (let i = 1; i <= period; i++) {
    const diff = closes[i] - closes[i - 1];
    if (diff > 0) gains += diff; else losses -= diff;
  }
  let avgGain = gains / period;
  let avgLoss = losses / period;
  let rs = avgLoss === 0 ? Infinity : avgGain / avgLoss;
  rsi[period] = 100 - 100 / (1 + rs);
  for (let i = period + 1; i < closes.length; i++) {
    const diff = closes[i] - closes[i - 1];
    const gain = diff > 0 ? diff : 0;
    const loss = diff < 0 ? -diff : 0;
    avgGain = (avgGain * (period - 1) + gain) / period;
    avgLoss = (avgLoss * (period - 1) + loss) / period;
    rs = avgLoss === 0 ? Infinity : avgGain / avgLoss;
    rsi[i] = 100 - 100 / (1 + rs);
  }
  for (let i = 0; i < period; i++) rsi[i] = NaN;
  return rsi;
}

async function fetchSymbols() {
  const res = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
  const data = await res.json();
  return data.symbols
    .filter(s => s.symbol.endsWith('USDT') && s.contractType === 'PERPETUAL')
    .map(s => s.symbol);
}

async function fetchKlines(symbol) {
  const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=15m&limit=500`;
  const res = await fetch(url);
  const data = await res.json();
  return data.map(c => ({
    time: c[0],
    open: +c[1],
    high: +c[2],
    low: +c[3],
    close: +c[4]
  }));
}

function detectRSICrossover(rsi, ema70, ema200) {
  for (let i = rsi.length - 3; i >= 1; i--) {
    const prev70 = ema70[i - 1], prev200 = ema200[i - 1];
    const curr70 = ema70[i], curr200 = ema200[i];
    if (prev70 <= prev200 && curr70 > curr200)
      return { type: 'bullish', index: i };
    if (prev70 >= prev200 && curr70 < curr200)
      return { type: 'bearish', index: i };
  }
  return null;
}

(async () => {
  const status = document.getElementById('status');
  const tbody = document.getElementById('results');
  const symbols = await fetchSymbols();
  status.textContent = `Scanning ${symbols.length} pairs...`;

  const BATCH_SIZE = 5;
  const MIN_DELAY = 400, MAX_DELAY = 800;
  let count = 0;

  for (let i = 0; i < symbols.length; i++) {
    const sym = symbols[i];
    try {
      const candles = await fetchKlines(sym);
      const closes = candles.map(c => c.close);
      const rsi = calculateRSI(closes, 14);
      const ema70 = calculateEMA(rsi, 70);
      const ema200 = calculateEMA(rsi, 200);
      const cross = detectRSICrossover(rsi, ema70, ema200);

      if (cross) {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${sym}</td>
          <td class="${cross.type}">${cross.type.toUpperCase()}</td>
          <td>${new Date(candles[cross.index].time).toLocaleString()}</td>
        `;
        tbody.appendChild(row);
      }
    } catch (err) {
      console.error(sym, err);
    }

    count++;
    if (count % BATCH_SIZE === 0)
      await new Promise(r => setTimeout(r, 2000)); // batch pause

    await new Promise(r =>
      setTimeout(r, Math.random() * (MAX_DELAY - MIN_DELAY) + MIN_DELAY)
    );
  }
  status.textContent = `âœ… Scan complete!`;
})();
</script>
</body>
</html>
